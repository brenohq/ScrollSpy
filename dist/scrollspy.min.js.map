{"version":3,"sources":["../src/scrollspy.ts"],"names":["winHeight","docHeight","items","throttle","callback","idle","setTimeout","getElementPos","item","top","getScrollY","el","getBoundingClientRect","reference","offset","pageYOffset","doc","document","documentElement","clientHeight","body","scrollTop","onResize","onScroll","currentDocHeight","offsetHeight","window","innerHeight","pos","checkVisibleItems","resetElementPosition","checkDocumentHeight","currentPos","currentPosOffset","shift","length","removeEventListener","param","Error","Object","assign","index","findIndex","i","splice","addEventListener","forEach","border","nodeHtml","createElement","css","join","style","className","setAttribute","appendChild","map"],"mappings":"uMAuBA,IACIA,EACAC,EAFAC,EAAyB,GAsD7B,SAASC,EAASC,GAChB,IAAIC,GAAO,EACX,MAAO,KACDA,IACFD,IACAC,GAAO,EACPC,WAAW,IAAOD,GAAO,EAAO,OAKtC,SAASE,EAAcC,GACrB,MAAMC,EAAMC,IAEZ,OADoBF,EAAKG,GAAGC,wBACTJ,EAAKK,WAAaJ,EAAMD,EAAKM,OAGlD,SAASJ,IACP,GAA2B,oBAAhBK,YACT,OAAOA,YACF,CACL,IAAIC,EAAMC,SAASC,gBAEnB,OADAF,EAAMA,EAAIG,aAAeH,EAAMC,SAASG,KACjCJ,EAAIK,WAIf,SAASC,KAQT,SAASC,KA4BT,WACE,MAAMC,EAAmBP,SAASG,KAAKK,aACnCxB,IAAcuB,IAChBvB,EAAYuB,EAhBhB,WACExB,EAAY0B,OAAOC,YACnB,IAAK,MAAMnB,KAAQN,EACjBM,EAAKoB,IAAMrB,EAAcC,GAE3BqB,IAYEC,IA/BFC,GACAF,IAkCF,SAASA,IACP,MAAMG,EAAatB,IACbuB,EAAmBjC,EAAYgC,EACrC,IAAK,MAAMxB,KAAQN,EAAO,CACxB,KAAI+B,GAAoBzB,EAAKoB,KAM3B,MALIpB,EAAKJ,UACPI,EAAKJ,WAEPF,EAAMgC,QAKLhC,EAAMiC,SAtCXT,OAAOU,oBAAoB,SAAUjC,EAASoB,IAC9CG,OAAOU,oBAAoB,SAAUjC,EAASmB,oBAzF5Be,GAClB,IAAKA,EAAM1B,GACT,MAAM,IAAI2B,MAAM,6CAElB,MAAM9B,EAAsB+B,OAAOC,OACjC,CAAE1B,OAAQ,IAAKD,UAAW,MAAOe,IAAK,GACtCS,GAEF7B,EAAKoB,IAAMrB,EAAcC,GAEzB,MAAMiC,EAAQvC,EAAMwC,UAAUC,GAAKA,EAAEf,IAAMpB,EAAKoB,KAEhD1B,EAAM0C,QAAkB,IAAXH,EAAevC,EAAMiC,OAASM,EAAO,EAAGjC,GAEhC,IAAjBN,EAAMiC,SAuFVnC,EAAY0B,OAAOC,YACnB1B,EAAYgB,SAASG,KAAOH,SAASG,KAAKK,aAAe,EAnBzDC,OAAOmB,iBAAiB,SAAU1C,EAASoB,IAC3CG,OAAOmB,iBAAiB,SAAU1C,EAASmB,KAlE3CO,wBAzBA3B,EAAQ,uBA8CR,OAjBAA,EAAM4C,QAAQ,CAACtC,EAAMmC,KACnB,MACMI,EAAS,eADDJ,EAAI,EAAI,MAAQ,QAExBK,EAAW/B,SAASgC,cAAc,OAClCC,EAAM,CACV,QAAQ1C,EAAKoB,OACb,eACA,sBACA,eAAemB,MACfI,KAAK,IAEP3C,EAAKG,GAAGyC,MAAML,OAASA,EAEvBC,EAASK,UAAY,aACrBL,EAASM,aAAa,QAASJ,GAC/BjC,SAASG,KAAKmC,YAAYP,KAErB9C,yBA1CP,OAAOA,EAAMsD,IAAIb,GAAKA","file":"dist/scrollspy.min.js.map","sourcesContent":["/*\n * Copyright (c) 2016, Globo.com (https://github.com/globocom)\n *\n * License: MIT\n */\n\nexport interface ScrollSpyItemOptions {\n  el: HTMLElement;\n  callback: () => void;\n  offset?: number;\n  reference?: ScrollSpyItemReference;\n}\n\nexport type ScrollSpyItemReference = \"top\" | \"bottom\";\n\nexport type ScrollSpyCallback = () => void;\n\nexport interface ScrollSpyItem extends ScrollSpyItemOptions {\n  offset: number;\n  reference: ScrollSpyItemReference;\n  pos: number;\n}\n\nlet items: ScrollSpyItem[] = [];\nlet winHeight: number;\nlet docHeight: number;\n\nexport function clean(): void {\n  items = [];\n}\n\nexport function getItems(): readonly Readonly<ScrollSpyItem>[] {\n  return items.map(i => i);\n}\n\nexport function add(param: ScrollSpyItemOptions): void {\n  if (!param.el) {\n    throw new Error(\"[@globocom/scrollspy] item.el is required\");\n  }\n  const item: ScrollSpyItem = Object.assign(\n    { offset: 200, reference: \"top\", pos: 0 },\n    param\n  );\n  item.pos = getElementPos(item);\n\n  const index = items.findIndex(i => i.pos > item.pos);\n\n  items.splice(index === -1 ? items.length : index, 0, item);\n\n  if (items.length === 1) {\n    setDefaultVariables();\n    startListener();\n  }\n  checkVisibleItems();\n}\n\nexport function debug(): ScrollSpyItem[] {\n  items.forEach((item, i) => {\n    const color = i % 2 ? \"red\" : \"blue\";\n    const border = `2px dashed ${color}`;\n    const nodeHtml = document.createElement(\"div\");\n    const css = [\n      `top: ${item.pos};`,\n      \"width: 100%;\",\n      \"position: absolute;\",\n      `border-top: ${border};`\n    ].join(\"\");\n\n    item.el.style.border = border;\n\n    nodeHtml.className = \"debug-line\";\n    nodeHtml.setAttribute(\"style\", css);\n    document.body.appendChild(nodeHtml);\n  });\n  return items;\n}\n\nfunction throttle(callback: ScrollSpyCallback): () => void {\n  let idle = true;\n  return () => {\n    if (idle) {\n      callback();\n      idle = false;\n      setTimeout(() => (idle = true), 150);\n    }\n  };\n}\n\nfunction getElementPos(item: ScrollSpyItem): number {\n  const top = getScrollY();\n  const boundClient = item.el.getBoundingClientRect();\n  return boundClient[item.reference] + top - item.offset;\n}\n\nfunction getScrollY(): number {\n  if (typeof pageYOffset !== \"undefined\") {\n    return pageYOffset;\n  } else {\n    let doc = document.documentElement;\n    doc = doc.clientHeight ? doc : document.body;\n    return doc.scrollTop;\n  }\n}\n\nfunction onResize(): void {\n  throttle(() => {\n    if (winHeight !== window.innerHeight) {\n      resetElementPosition();\n    }\n  });\n}\n\nfunction onScroll(): void {\n  checkDocumentHeight();\n  checkVisibleItems();\n}\n\nfunction startListener(): void {\n  window.addEventListener(\"scroll\", throttle(onScroll));\n  window.addEventListener(\"resize\", throttle(onResize));\n}\n\nfunction stopListeners(): void {\n  window.removeEventListener(\"scroll\", throttle(onScroll));\n  window.removeEventListener(\"resize\", throttle(onResize));\n}\n\nfunction resetElementPosition(): void {\n  winHeight = window.innerHeight;\n  for (const item of items) {\n    item.pos = getElementPos(item);\n  }\n  checkVisibleItems();\n}\n\nfunction setDefaultVariables(): void {\n  winHeight = window.innerHeight;\n  docHeight = document.body ? document.body.offsetHeight : 0;\n}\n\nfunction checkDocumentHeight(): void {\n  const currentDocHeight = document.body.offsetHeight;\n  if (docHeight !== currentDocHeight) {\n    docHeight = currentDocHeight;\n    resetElementPosition();\n  }\n}\n\nfunction checkVisibleItems(): void {\n  const currentPos = getScrollY();\n  const currentPosOffset = winHeight + currentPos;\n  for (const item of items) {\n    if (currentPosOffset >= item.pos) {\n      if (item.callback) {\n        item.callback();\n      }\n      items.shift();\n    } else {\n      break;\n    }\n  }\n  if (!items.length) {\n    stopListeners();\n  }\n}\n"]}